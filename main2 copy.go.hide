package main

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

type player struct {
	uid, name string
	conn      *websocket.Conn
}

type room struct {
	players []player
}

var rooms = make(map[string]*room) //roomKey

func getPlayerIdx(roomKey string, uid string) int {
	players := rooms[roomKey].players
	for i := 0; i < len(players); i++ {
		if players[i].uid == uid {
			return i
		}
	}

	return -1 //見つからなかったとき
}

func cmd(w http.ResponseWriter, r *http.Request) {
	upgrader.CheckOrigin = func(r *http.Request) bool { return true }
	//リモートアドレスからのアクセスを許可する
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		println(err.Error())
		return
	}

	println(r.RemoteAddr)

	// 無限ループさせることでクライアントからのメッセージを受け付けられる状態にする
	myUid := MakeUuid()
	roomKey := ""

	for {
		msgType, msg, err := conn.ReadMessage()
		if err != nil { //通信終了時の処理
			if roomKey == "" {
				break
			}

			pIdx := getPlayerIdx(roomKey, myUid)
			if pIdx != -1 { //自分が部屋にいたら部屋から抜ける
				a := rooms[roomKey].players
				a[pIdx] = a[len(a)-1]
				a = a[:len(a)-1]
				rooms[roomKey].players = a

				if len(rooms[roomKey].players) == 1 {
					println(len(rooms[roomKey].players))
					println(rooms[roomKey].players[0].name)
					println(rooms[roomKey].players[0].conn)
					//他プレイヤーへ退出したことを通知
					rooms[roomKey].players[0].conn.WriteMessage(msgType, []byte("disConnect"))
					time.Sleep(5 * time.Second)
				}
			}

			println("切断")
			break
		}

		//msgのコマンド読み取り
		cmd := strings.Split(string(msg), " ")
		cmdType := cmd[0]
		cmdLen := len(cmd)

		//コマンドに応じた処理をする
		if cmdType == "roomMatch" && cmdLen == 4 { //マッチングコマンド。想定コマンド = "roomMatch 部屋番号 部屋パスワード プレイヤー名"
			roomKey = cmd[1] + cmd[2]
			pName := cmd[3]

			if val, ok := rooms[roomKey]; !ok { //まだ部屋が無いなら作る
				fmt.Printf("isRoom : %v", val)
				rooms[roomKey] = &room{players: []player{}}
			}

			playerNum := len(rooms[roomKey].players)

			myIdx := getPlayerIdx(roomKey, myUid)
			if playerNum == 2 { //部屋がいっぱいなら
				err = conn.WriteMessage(msgType, []byte("fullMember"))

			} else if playerNum < 2 { //人数が揃ってないとき
				if myIdx == -1 { //まだ自分が部屋に入ってなかったら追加
					rooms[roomKey].players = append(rooms[roomKey].players, player{uid: myUid, name: pName, conn: conn})

					rooms[roomKey].players[0].conn.WriteMessage(msgType, []byte("test disConnect"))

					myIdx = getPlayerIdx(roomKey, myUid)
					rooms[roomKey].players[myIdx].conn = conn

					playerNum = len(rooms[roomKey].players)
				}

				msg := ""
				if playerNum == 2 { //人数が揃った時
					msg = "matched"
				} else if playerNum == 1 {
					msg = "matching " + strconv.Itoa(playerNum)
				}

				println(rooms[roomKey].players[playerNum-1].name)
				println(rooms[roomKey].players[playerNum-1].conn)

				for i := 0; i < len(rooms[roomKey].players); i++ {
					err = rooms[roomKey].players[i].conn.WriteMessage(msgType, []byte(msg))
				}
			}

		} else if cmdType == "move" && cmdLen == 5 { //移動コマンド。想定コマンド = "move pieceId toX toY reverse"
			println(msg)
			//自分以外にコマンド送信
			for i := 0; i < len(rooms[roomKey].players); i++ {
				if rooms[roomKey].players[i].conn == conn {
					continue
				}

				rooms[roomKey].players[i].conn.WriteMessage(msgType, msg)
			}
		} else {
			println(cmdType)
		}

		if err != nil {
			print(err.Error())
		}
	}
}

func test(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "test.html")
}

func main() {
	// ハンドラの設定
	mux := http.NewServeMux() //ミューテックス。すでに起動してるか確認。
	mux.HandleFunc("/shogi/test", test)
	mux.HandleFunc("/shogi/cmd", cmd)

	//tls設定
	cfg := &tls.Config{
		ClientAuth: tls.RequestClientCert,
	}

	//サーバー設定
	srv := &http.Server{
		Addr:      ":8443",
		Handler:   mux,
		TLSConfig: cfg,
	}

	// http.HandleFunc("/postRequest", handler)
	println("サーバー起動")
	err := srv.ListenAndServeTLS("/etc/letsencrypt/live/os3-382-24260.vs.sakura.ne.jp/fullchain.pem", "/etc/letsencrypt/live/os3-382-24260.vs.sakura.ne.jp/privkey.pem")
	if err != nil {
		println(err.Error())
	}
}
